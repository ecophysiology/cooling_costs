#---------------------#
#------DESCRIPTION----#
#---------------------#
'''The following version of this endotherm code predicts many different kinds
of physiological stress indices for desert bird species that have significantly declined over
the last 100 years. It uses the average coordinates for the Mojave to get an index of stress of 
the species. This script only works for birds in the southern region of California.
'''

#---------------------#
#------LIBRARIES------#
#---------------------#

from numpy import *
from math import *
from scipy.interpolate import *
from random import * 
from matplotlib import pylab
from pylab import *
import matplotlib.pyplot as plt
from pandas import *
import six
import numpy as np
from collections import OrderedDict
import time
import glob

#--------------------#
#-----CONSTANTS------#
#--------------------#

SOLAR_CONSTANT = 1360. #W*m^-2
TAU = 0.7 #0.7 clear day
STEFAN_BOLTZMANN = 5.670373*10**(-8) #W*m^-2*K^-4
ALBEDO = 0.4 #ground reflectance (albedo) of dry sandy soil ranges 0.25-0.45
E_G = 0.9 ##surface emissivity of sandy soil w/<2% organic matter approx 0.88
OMEGA = pi/12.

#-------------------#
#-----CLASSESS------#
#-------------------#

class Individual():
    def __init__(self,endotherm_type,scenario,common_name,latitude,longitude,length,width,height,feather_length_dorsal,feather_length_ventral,density_of_fibers,insulation_depth_dorsal,insulation_depth_ventral,physiology_known,Tb,Tb_max,LCT,UCT,mass,shortwave_absorbance_dorsal,shortwave_absorbance_ventral,longwave_absorbance,water_heat_ratio_slope,water_heat_ratio_intercept,water_loss_slope,water_loss_intercept,Tb_slope1,Tb_slope2,Tb_intercept,windspeed,posture,fiber_density,shade,feather_depths,orientation,shape,water_threshold):
        'the classes object that holds the relevant morphological, physiological, and geographic information for the animal'
        self.type = endotherm_type #bird only  
        self.scenario = scenario #modern or historic
        self.common_name = common_name #name of animal
        self.latitude = latitude #decimal degrees
        self.longitude = longitude #decimal degrees
        self.altitude = 1285.#meters
        self.MASS = mass #grams
        self.dehydration_mass = mass #grams
        self.density_of_fibers = density_of_fibers + (density_of_fibers*fiber_density)#fiber number is density
        self.animal_slope = 60.0 + (60.0 * posture)
        self.orientation = orientation
        self.body_volume = (self.MASS/0.99)/1000000 #m^3
        self.T_b = Tb
        self.Tes_past = 0.0
        self.Qgen_past = 0.0
        self.Tb_max = Tb_max
        self.Tb_slope1 = Tb_slope1
        self.Tb_slope2 = Tb_slope2
        self.Tb_intercept = Tb_intercept
        self.lower_critical_temperature = LCT
        self.upper_critical_temperature = UCT
        self.thermoneutral_zone_range = self.upper_critical_temperature - self.lower_critical_temperature
        self.insulation_depth_dorsal = insulation_depth_dorsal + (insulation_depth_dorsal * feather_depths)
        self.insulation_depth_ventral = insulation_depth_ventral + (insulation_depth_ventral * feather_depths)
        self.A_radius = length/2.0 - ((length/2.0) * (shape*0.35)) #radius of length of prolate spheroid
        self.B_radius = width/2.0 - ((width/2.0) * (shape*0.35))#radius of width of prolate spheroid
        self.C_radius = height/2.0 - ((height/2.0) * (shape*0.35))#radius of height of prolate spheroid
        self.insulation_length_dorsal = feather_length_dorsal
        self.insulation_length_ventral = feather_length_ventral
        self.D = (self.body_volume)**(1.0/3.0) #characteristic dimension
        self.H = self.A_radius * 2.0 #length of cylinder, meters
        self.S = 1.0 + shade #proportion of animal exposed to direct solar radiation (non-shaded)
        self.A_S_dorsal = shortwave_absorbance_dorsal #absorptance of organism to shortwave radiation
        self.A_S_ventral = shortwave_absorbance_ventral
        self.A_L = longwave_absorbance #absorptance of organism to longwave radiation
        self.E_S = 0.97 #emissivity of organism
        self.conductivity_insulation = 0.075 #thermal conductivity of insulation W/m C
        self.A_radius_insulation = self.A_radius# + self.insulation_depth_dorsal #radius of length of prolate spheroid
        self.B_radius_insulation = self.B_radius# + self.insulation_depth_dorsal #radius of width of prolate spheroid
        self.C_radius_insulation = self.C_radius# + self.insulation_depth_dorsal #radius of height of prolate spheroid
        self.surface_area_outer = (4*pi*(((((self.A_radius_insulation*self.B_radius_insulation)**1.6)+((self.A_radius_insulation*self.C_radius_insulation)**1.6)+((self.B_radius_insulation*self.C_radius_insulation)**1.6))/3.0)**(1/1.6)))#*1.3
        self.surface_area_inner = 1.23 * self.surface_area_outer
        self.surface_area_outer_cold = self.surface_area_outer * 0.7395844496812287
        self.surface_area_inner_cold = self.surface_area_inner * 0.7395844496812287
        self.surface_area_outer_splayed  = self.surface_area_outer * 1.2
        self.surface_area_inner_splayed  = self.surface_area_inner * 1.2
        self.conductance_insulation_dorsal = self.conductivity_insulation/self.insulation_depth_dorsal#W K-1
        self.conductance_insulation_ventral = self.conductivity_insulation/self.insulation_depth_ventral#W K-1
        self.conductivity_skin = 2.8 #thermal conductivity of skin W m-1 C-1
        self.skin_depth = 0.01 * (self.D**(0.6))#Bakken 1976
        self.conductance_skin = self.conductivity_skin/self.skin_depth#Bakken 1976,W m-2 K-1
        self.conductance_skin_insulation_dorsal = ((self.conductance_skin*(self.surface_area_inner/2.0)) * (self.conductance_insulation_dorsal*(self.surface_area_outer/2.0)))/((self.conductance_skin*(self.surface_area_inner/2.0)) + (self.conductance_insulation_dorsal*(self.surface_area_outer/2.0)))
        self.conductance_skin_insulation_ventral = ((self.conductance_skin*(self.surface_area_inner/2.0)) * (self.conductance_insulation_ventral*(self.surface_area_outer/2.0)))/((self.conductance_skin*(self.surface_area_inner/2.0)) + (self.conductance_insulation_ventral*(self.surface_area_outer/2.0)))
        self.windspeed = windspeed #m/s
        self.physiology_known = physiology_known# 1 is known, 0 is unknown
        self.water_heat_ratio_slope = water_heat_ratio_slope #slope of relationship between EHL and MHP from empirical data
        self.water_heat_ratio_intercept = water_heat_ratio_intercept #intercept of relationship between EHL and MHP from empirical data
        self.water_heat_ratio = self.water_heat_ratio_intercept**(self.water_heat_ratio_slope*self.T_b)#amount of water lost relative to heat produced
        self.resting_metabolic_rate = 0.0#Watts
        self.water_loss_slope = water_loss_slope#slope of relationship between EHL and air temperature from empirical data
        self.water_loss_intercept = water_loss_intercept#intercept of relationship between EHL and air temperature from empirical data
        self.evaporative_heat_loss = 0.0 #Watts
        self.water_heat_balance = 0.0 #Watts
        self.energy_balance = 0.0 #Watts
        self.water_loss_mass = 0.0 #grams
        self.excess_proportion_of_mass_lost = 0.0 #grams
        self.excess_water = 0.0 # grams
        self.metabolic_heat_required = 0.0 #Watts
        self.water_loss_required = 0.0 #grams
        self.proportion_water_loss_required = 0.0 #proportion of mass
        self.excess_metabolic_heat = 0.0 #Watts
        self.Qgen_water = 0.0 #Watts
        self.Qgen_heat = 0.0#Watts
        self.activity_above_thermal_stress = 0.0
        self.activity_above_water_stress = 0.0
        self.heat_stress = 0.0
        self.water_stress = 0.0
        self.Qgen_water_sum = 0.0
        self.Qgen_water_threshold = water_threshold
        self.active_hours = 0.0
    
    def orbit_correction(self,day):
        'orbital correction for day'
        return 1 + 2 * 0.01675 * cos((((2*pi)/365))*day)
    
    def direct_solar_radiation(self,day):
        'required for solar radiation'
        return self.orbit_correction(day)*SOLAR_CONSTANT
        
    def f(self,day):
        'requried for solar declination and equation of time'
        return 279.575 + (0.9856 * day)
    
    def ET(self,day):
        'equation of time'
        _f = radians(self.f(day))
        return (-104.7*sin(_f)+596.2*sin(2*_f)+4.3*sin(3*_f)-12.7*sin(4*_f)-429.3*cos(_f)-2.0*cos(2*_f)+19.3*cos(3*_f))/3600.
    
    def LC(self,lon):
        'longitude correction'
        return ((lon%15)*4.0)/60

    def t0(self,lc,et):
        'solar noon'
        t = 12 + lc - et
        return t

    def hour(self,t,t_zero):
        'conversion for zenith angle'
        h = 15*(t-t_zero)
        return h

    def declin(self,day):
        'declination angle'
        return degrees(asin(0.39785* sin(radians(278.97 + 0.9856 * day + 1.9165 * sin(radians(356.6 + 0.9856 * day))))))
        
    def zenith(self,day,t):
        'zenith angle'
        if acos(sin(radians(self.latitude))*sin(radians(self.declin(day))) + cos(radians(self.latitude))*cos(radians(self.declin(day)))*cos(radians(self.hour(t,(self.t0(self.LC(self.longitude),self.ET(day))))))) >= 0.:
            return acos(sin(radians(self.latitude))*sin(radians(self.declin(day))) + cos(radians(self.latitude))*cos(radians(self.declin(day)))*cos(radians(self.hour(t,(self.t0(self.LC(self.longitude),self.ET(day)))))))
        else:
            return 0.
            
    def azimuth(self,day,t):
        'azimuth angle'
        return (acos(-1.*(-(sin(radians(self.declin(day)))-(cos(self.zenith(day,t))*sin(radians(self.latitude)))))/((cos(radians(self.latitude)))*sin(self.zenith(day,t)))))
        
    def animal_angle(self,day,t):
        'angle of the animal'
        return (acos((cos(radians(self.animal_slope)) * cos(self.zenith(day,t))) + (sin(radians(self.animal_slope)) * sin(self.zenith(day,t)) * cos(self.azimuth(day,t)-radians(180.- self.animal_slope)))))
            
    def m(self,day,hrs):
        'optical air mass number'
        p_a = 101.3*exp(-self.altitude/8200)
        if cos(self.zenith(day,hrs))>=0.:
            return p_a/(101.3*(cos(self.zenith(day,hrs))))
        else:
            return 0.
            
    def hS0(self,day,hrs):
        'direct solar radiation'
        z = self.zenith(day,hrs)
        if cos(z)>= 0.:
            return self.direct_solar_radiation(day)*(cos(z))
        else:
            return 0.
            
    def hS(self,day, hrs, tau):
        'solar radiation, corrected'
        return self.hS0(day,hrs)*tau**self.m(day,hrs)

    def diffuse_solar(self,day,hrs,tau):
        'diffuse solar radiation'
        return self.hS0(day,hrs)*0.3*(1.-(TAU**self.m(day,hrs)))

    def reflected_radiation(self,day,t,tau):
        'reflected solar radiation'
        return ALBEDO*self.hS(day,t,tau)
               
    def view_factor_hemisphere_cylinder(self,zenith):
        'view factor for hemosphere cylinger'
        return (1.+((4.*(self.H)*sin(radians(90.-degrees(zenith))))/(pi*(self.D))))/(4.+(4.*(self.H)/(self.D)))
    
    def view_factor_prolate_spheroid(self,animal_angle,a,b):
        'view factor for prolate spheroid'
        view_factor = ((sqrt(1+((((b/a)**2)-1)*((cos(radians(90.-degrees(animal_angle))))**2))))/((2*(b/a))+((2*(asin(sqrt((1-((b/a)**2))))))/(sqrt((1-((b/a)**2)))))))
        return view_factor + (view_factor * self.orientation)

    def dimensionless_temperature(self,hour):
        'dimensionaless temperature'
        return 0.44-(0.46*sin(((pi/12.)*hour)+0.9))+0.11*sin(2.*(pi/12.)*hour+0.9)
    
    def air_temp(self,mins,maxes,day,hour):
        'air temperature function'
        day = int(day)
        if hour > -1.0 and hour <= 5.:
            return maxes[day-1]*self.dimensionless_temperature(hour)+mins[day]*(1-self.dimensionless_temperature(hour))
        if hour > 5. and hour <= 14.:
            return maxes[day]*self.dimensionless_temperature(hour)+mins[day]*(1-self.dimensionless_temperature(hour))
        if hour >14 and hour <= 25.:
            return maxes[day]*self.dimensionless_temperature(hour)+mins[day+1]*(1-self.dimensionless_temperature(hour))
        
    def ground_temp_NicheMapR(self,day,hour):
        'function for referencing files with NicheMapR output'
        if self.scenario == 'historic':
            soil_df = pandas.read_csv('your_path/historic_soil.csv')
        elif self.scenario == 'modern':
            soil_df = pandas.read_csv('your_path/modern_soil.csv')
        elif self.scenario == 'CURR':
            soil_df = pandas.read_csv('your_path/CURR_soil.csv')
        elif self.scenario == 'CC45':
            soil_df = pandas.read_csv('your_path/RCP45_soil.csv')
        elif self.scenario == 'CC60':
            soil_df = pandas.read_csv('your_path/RCP60_soil.csv')
        elif self.scenario == 'CC85':
            soil_df = pandas.read_csv('your_path/RCP85_soil.csv')
        elif self.scenario == 'site1':
            soil_df = pandas.read_csv('your_path/site1_soil.csv')
        elif self.scenario == 'site2':
            soil_df = pandas.read_csv('your_path/site2_soil.csv')
        elif self.scenario == 'site3':
            soil_df = pandas.read_csv('your_path/site3_soil.csv')
        elif self.scenario == 'site4':
            soil_df = pandas.read_csv('your_path/site4_soil.csv')
        elif self.scenario == 'site5':
            soil_df = pandas.read_csv('your_path/site5_soil.csv')
        elif self.scenario == 'site6':
            soil_df = pandas.read_csv('your_path/site6_soil.csv')
        return soil_df.D0cm[int((int((day-15)/30) * 24) + int(hour))]

    def longwave_sky(self,temperature):
        'longwave radiation from sky'
        return 53.1*10**-14*(temperature+273.15)**6.

    def longwave_ground(self,temperature):
        'longwave radiation from the ground'
        return E_G*STEFAN_BOLTZMANN*(temperature+273.15)**4.
            
    def radiative_conductance(self,mins,maxes,day,hour,soil_mins,soil_maxes):
        'radiative conductance'
        if self.type == "bird":
            return (4.0 * (self.surface_area_outer/2.0) * STEFAN_BOLTZMANN * self.E_S * ((self.air_temp(mins,maxes,day,hour)+273.15)**3.))
        else:
            print("Warning: incorrect endotherm type for radiative conductance")
    
    def convective_conductance(self,mins,maxes,day,hour,soil_mins,soil_maxes,windspeed):
        'convective conductance'
        if self.type == "bird":
            air_pressure = (101325.*(1.-(2.2569*10**-5)*self.altitude)**5.2553)
            temp_K = self.air_temp(mins,maxes,day,hour) + 273.15
            thermal_conductivity = (2.4525*10**-2)+((7.038*10**-5)*(temp_K-273.15))
            air_density = air_pressure/(287.04*temp_K)
            dynamic_viscosity = (1.8325*10**-5)*((296.16+120.)/(temp_K+120.))*((temp_K/296.16)**1.5)
            Reynolds = (air_density*windspeed*self.D)/dynamic_viscosity
            Nusselt = 0.37*(Reynolds**0.6)
            hc = (Nusselt*thermal_conductivity)/self.D
            hc_enhanced = hc * 1.3 #if bird, enhancement based upon Mitchell 1976
            return hc_enhanced * (self.surface_area_outer/2.0) #W K-1
        else:
            print("Warning: incorrect endotherm type")
            
    def probability(self,day,time):
        'probability radiation passes through feathers'
        return (self.density_of_fibers * 10000.) * 0.00003 * ((((1. + (tan(arccos(self.insulation_depth_dorsal/self.insulation_length_dorsal))**2.))*(1. + (tan(self.animal_angle(day,time))**2.)))-((1.+ tan(arccos(self.insulation_depth_dorsal/self.insulation_length_dorsal))*tan(self.animal_angle(day,time))*cos(self.azimuth(day,time)))**2.))**(1./2.))
    
    def radiation_abs(self,area,mins,maxes,day,hour,tau,soil_mins,soil_maxes,windspeed):
        'radiation absorbed on the ith side'
        if area == "dorsal" and self.type == "bird":
            return ((self.S*(self.A_S_dorsal + ((self.convective_conductance(mins,maxes,day,hour,soil_mins,soil_maxes,windspeed)+self.radiative_conductance(mins,maxes,day,hour,soil_mins,soil_maxes))/(self.conductance_insulation_dorsal*(self.surface_area_outer/2.0)))*(1./(self.probability(day,hour) * self.insulation_length_dorsal)) * (2.-self.A_S_dorsal)))*((self.view_factor_prolate_spheroid(self.animal_angle(day,hour),self.A_radius*2,self.B_radius*2)*self.hS0(day,hour))+((self.diffuse_solar(day,hour,tau)))))+(self.A_L*((self.longwave_sky(self.air_temp(mins,maxes,day,hour)))))
        elif area == "ventral" and self.type == "bird":
            return ((self.S*(self.A_S_ventral + ((self.convective_conductance(mins,maxes,day,hour,soil_mins,soil_maxes,windspeed)+self.radiative_conductance(mins,maxes,day,hour,soil_mins,soil_maxes))/(self.conductance_insulation_ventral*(self.surface_area_outer/2.0)))*(1./(self.probability(day,hour) * self.insulation_length_ventral)) * (2.-self.A_S_ventral)))*((self.reflected_radiation(day,hour,tau))))+(self.A_L*(self.longwave_ground(self.ground_temp_NicheMapR(day,hour))))
        else:
            print("Warning in radiation absorbed")
  
    def effective_conductance(self,area,radiative_conductance, convective_conductance):
        'effective conductance'
        if area == "dorsal":
            return (self.conductance_skin_insulation_dorsal*(radiative_conductance + (convective_conductance)))/(self.conductance_skin_insulation_dorsal + radiative_conductance + convective_conductance)
        elif area == "ventral":
            return (self.conductance_skin_insulation_ventral*(radiative_conductance + (convective_conductance)))/(self.conductance_skin_insulation_ventral + radiative_conductance + convective_conductance)
        else:
            print("Warning in effective conductance")
            
    def Ke_overall(self,mins,maxes,day,hour,soil_mins,soil_maxes,field_windspeed):
        'Overall conductance'
        field_dorsal_conductance = self.effective_conductance("dorsal",self.radiative_conductance(mins,maxes,day,hour,soil_mins,soil_maxes),self.convective_conductance(mins,maxes,day,hour,soil_mins,soil_maxes,field_windspeed))
        field_ventral_conductance = self.effective_conductance("ventral",self.radiative_conductance(mins,maxes,day,hour,soil_mins,soil_maxes),self.convective_conductance(mins,maxes,day,hour,soil_mins,soil_maxes,field_windspeed))
        return field_dorsal_conductance + field_ventral_conductance

    def Q_gen(self,mins,maxes,day,hour,tau,soil_mins,soil_maxes,field_windspeed):
        'this calculates dorsal and ventral net sensible heat flux independently and then adds them together'
        if self.type == "bird":
            dorsal_Te = self.air_temp(mins,maxes,day,hour) + (((self.radiation_abs('dorsal',mins,maxes,day,hour,tau,soil_mins,soil_maxes,field_windspeed)*(self.surface_area_outer/2.))-(self.E_S*STEFAN_BOLTZMANN*((273.5 + self.air_temp(mins,maxes,day,hour))**4)*(self.surface_area_outer/2.)))/((self.convective_conductance(mins,maxes,day,hour,soil_mins,soil_maxes,field_windspeed))+self.radiative_conductance(mins,maxes,day,hour,soil_mins,soil_maxes))) #Bakken, bird
            ventral_Te = self.air_temp(mins,maxes,day,hour) + (((self.radiation_abs('ventral',mins,maxes,day,hour,tau,soil_mins,soil_maxes,field_windspeed)*(self.surface_area_outer/2.))-(self.E_S*STEFAN_BOLTZMANN*((273.5 + self.air_temp(mins,maxes,day,hour))**4)*(self.surface_area_outer/2.)))/((self.convective_conductance(mins,maxes,day,hour,soil_mins,soil_maxes,field_windspeed))+self.radiative_conductance(mins,maxes,day,hour,soil_mins,soil_maxes))) #Bakken, bird
            dorsal_conductance_standard = self.effective_conductance("dorsal",self.radiative_conductance(mins,maxes,day,hour,soil_mins,soil_maxes),self.convective_conductance(mins,maxes,day,hour,soil_mins,soil_maxes,self.windspeed))
            ventral_conductance_standard = self.effective_conductance("ventral",self.radiative_conductance(mins,maxes,day,hour,soil_mins,soil_maxes),self.convective_conductance(mins,maxes,day,hour,soil_mins,soil_maxes,self.windspeed))
            dorsal_conductance_field = self.effective_conductance("dorsal",self.radiative_conductance(mins,maxes,day,hour,soil_mins,soil_maxes),self.convective_conductance(mins,maxes,day,hour,soil_mins,soil_maxes,field_windspeed))
            ventral_conductance_field = self.effective_conductance("ventral",self.radiative_conductance(mins,maxes,day,hour,soil_mins,soil_maxes),self.convective_conductance(mins,maxes,day,hour,soil_mins,soil_maxes,field_windspeed))
            relative_conductance_dorsal = dorsal_conductance_field/dorsal_conductance_standard
            relative_conductance_ventral = ventral_conductance_field/ventral_conductance_standard
            Tes_dorsal = relative_conductance_dorsal*dorsal_Te + (1. - relative_conductance_dorsal)*self.T_b
            Tes_ventral = relative_conductance_ventral*ventral_Te + (1. - relative_conductance_ventral)*self.T_b
            Qgen_dorsal = dorsal_conductance_field*(self.T_b - Tes_dorsal)
            Qgen_ventral = ventral_conductance_field*(self.T_b - Tes_ventral)
        return Qgen_dorsal + Qgen_ventral
        
    def operative_temperature(self,mins,maxes,day,hour,tau,soil_mins,soil_maxes,windspeed):
        'operative temperature'
        if self.type == "bird":
            dorsal_Te = self.air_temp(mins,maxes,day,hour) + (((self.radiation_abs('dorsal',mins,maxes,day,hour,tau,soil_mins,soil_maxes,windspeed)*(self.surface_area_outer/2.))-(self.E_S*STEFAN_BOLTZMANN*((273.5 + self.air_temp(mins,maxes,day,hour))**4)*(self.surface_area_outer/2.)))/((self.convective_conductance(mins,maxes,day,hour,soil_mins,soil_maxes,windspeed))+self.radiative_conductance(mins,maxes,day,hour,soil_mins,soil_maxes))) #Bakken, bird
            ventral_Te = self.air_temp(mins,maxes,day,hour) + (((self.radiation_abs('ventral',mins,maxes,day,hour,tau,soil_mins,soil_maxes,windspeed)*(self.surface_area_outer/2.))-(self.E_S*STEFAN_BOLTZMANN*((273.5 + self.air_temp(mins,maxes,day,hour))**4)*(self.surface_area_outer/2.)))/((self.convective_conductance(mins,maxes,day,hour,soil_mins,soil_maxes,windspeed))+self.radiative_conductance(mins,maxes,day,hour,soil_mins,soil_maxes))) #Bakken, bird
            dorsal_conductance = self.effective_conductance("dorsal",self.radiative_conductance(mins,maxes,day,hour,soil_mins,soil_maxes),self.convective_conductance(mins,maxes,day,hour,soil_mins,soil_maxes,windspeed))
            ventral_conductance = self.effective_conductance("ventral",self.radiative_conductance(mins,maxes,day,hour,soil_mins,soil_maxes),self.convective_conductance(mins,maxes,day,hour,soil_mins,soil_maxes,windspeed))
            total_conductance = dorsal_conductance + ventral_conductance
            return ((dorsal_conductance * dorsal_Te)+(ventral_conductance * ventral_Te))/total_conductance
        else:
            print("Error in operative temperature")
    
    def standard_operative_temperature(self,mins,maxes,day,hour,tau,soil_mins,soil_maxes,field_windspeed):
        'standard operative temperture'
        dorsal_conductance = self.effective_conductance("dorsal",self.radiative_conductance(mins,maxes,day,hour,soil_mins,soil_maxes),self.convective_conductance(mins,maxes,day,hour,soil_mins,soil_maxes,self.windspeed))
        ventral_conductance = self.effective_conductance("ventral",self.radiative_conductance(mins,maxes,day,hour,soil_mins,soil_maxes),self.convective_conductance(mins,maxes,day,hour,soil_mins,soil_maxes,self.windspeed))
        standard_overall_conductance = dorsal_conductance + ventral_conductance
        field_dorsal_conductance = self.effective_conductance("dorsal",self.radiative_conductance(mins,maxes,day,hour,soil_mins,soil_maxes),self.convective_conductance(mins,maxes,day,hour,soil_mins,soil_maxes,field_windspeed))
        field_ventral_conductance = self.effective_conductance("ventral",self.radiative_conductance(mins,maxes,day,hour,soil_mins,soil_maxes),self.convective_conductance(mins,maxes,day,hour,soil_mins,soil_maxes,field_windspeed))
        field_total_conductance = field_dorsal_conductance + field_ventral_conductance
        relative_conductance = field_total_conductance/standard_overall_conductance
        return self.T_b - relative_conductance*(self.T_b - self.operative_temperature(mins,maxes,day,hour,tau,soil_mins,soil_maxes,field_windspeed))
        
    def update_skin_conductance(self,Tes):
        'adjusts skin conductance based on operative temperature'
        if Tes <= self.lower_critical_temperature:
            self.conductivity_skin = 0.204
        elif Tes >= self.upper_critical_temperature:
            self.conductivity_skin = 2.8
        elif Tes > self.lower_critical_temperature and Tes < self.upper_critical_temperature:
           self.conductivity_skin = 2.8 * ((Tes - self.lower_critical_temperature)/self.thermoneutral_zone_range)
        self.conductance_skin = self.conductivity_skin/self.skin_depth
        self.conductance_skin_insulation_dorsal = ((self.conductance_skin*(self.surface_area_inner/2.0)) * (self.conductance_insulation_dorsal*(self.surface_area_outer/2.0)))/((self.conductance_skin*(self.surface_area_inner/2.0)) + (self.conductance_insulation_dorsal*(self.surface_area_outer/2.0)))
        self.conductance_skin_insulation_ventral = ((self.conductance_skin*(self.surface_area_inner/2.0)) * (self.conductance_insulation_ventral*(self.surface_area_outer/2.0)))/((self.conductance_skin*(self.surface_area_inner/2.0)) + (self.conductance_insulation_ventral*(self.surface_area_outer/2.0)))
    
    def update_Tb(self,Tes,Tb_max):
        'adjusts body temperature, if known empirically'
        if Tes <= 30.0:
            self.T_b  = (self.Tb_slope1 * 30.) + (self.Tb_slope2 * (30.0**2)) + self.Tb_intercept
        elif Tes > 30 and Tes <= 55:
            self.T_b  = (self.Tb_slope1 * Tes) + (self.Tb_slope2 * (Tes**2)) + self.Tb_intercept
        else:
            self.T_b  = (self.Tb_slope1 * 55.) + (self.Tb_slope2 * (55.**2)) + self.Tb_intercept
        if self.T_b > Tb_max:
            self.T_b = Tb_max
            
    def update_water_loss_rate(self,Tes):#2.41 J mg^-1;rates are g/hour
        'adjusts water loss rates, if known empirically'
        if Tes <= 30.0:
            self.evaporative_heat_loss = (self.water_loss_intercept*exp((self.water_loss_slope*30.)))/1000.
        elif Tes > 30:
            self.evaporative_heat_loss = (self.water_loss_intercept*exp((self.water_loss_slope*Tes)))/1000.
            
    def update_water_heat_ratio(self,Tes):
        'calculation for adjusting metabolic heat production, if known empirically'
        if Tes <= 30.0:
            self.water_heat_ratio = self.water_heat_ratio_intercept*exp((self.water_heat_ratio_slope*30.0))
        elif Tes > 30:
            self.water_heat_ratio = self.water_heat_ratio_intercept*exp((self.water_heat_ratio_slope*Tes))
        self.resting_metabolic_rate = self.evaporative_heat_loss/self.water_heat_ratio
            
    def update_water_heat_balance(self):
        'adjusts water heat balance if known empirically'
        self.water_heat_balance = self.evaporative_heat_loss - self.resting_metabolic_rate
            
    def update_energy_balance(self,Qgen):
        'a function that helps create the final csv'
        self.energy_balance = Qgen + self.water_heat_balance
        if self.energy_balance > 0.0 and Qgen < 0.0:#if you're losing heat because water loss rates exceed heat gained and it's hot outside
            self.water_loss_mass = (((self.evaporative_heat_loss)/2.41)*3600)/1000.
            self.dehydration_mass -= self.water_loss_mass
            self.excess_water = ((self.energy_balance/2.41)*3600)/1000.
            self.excess_proportion_of_mass_lost = ((self.excess_water)/self.MASS)
            self.metabolic_heat_required = 0.0
            self.water_loss_required = 0.0
            self.proportion_water_loss_required = 0.0
            self.excess_metabolic_heat = 0.0
            self.water_stress = Qgen + self.evaporative_heat_loss
            self.heat_stress = 0.0
        elif self.energy_balance > 0.0 and Qgen > 0.0:#if you're losing heat because it's cold
            self.water_loss_mass = (((self.evaporative_heat_loss)/2.41)*3600)/1000.
            self.dehydration_mass -= self.water_loss_mass
            self.excess_water = 0.0
            self.excess_proportion_of_mass_lost = 0.0
            self.metabolic_heat_required = self.energy_balance
            self.water_loss_required = 0.0
            self.proportion_water_loss_required = 0.0
            self.excess_metabolic_heat = 0.0
            self.water_stress = 0.0
            self.heat_stress = Qgen - self.resting_metabolic_rate
        elif self.energy_balance < 0.0 and Qgen < 0.0:# if you're gaining heat because it's hot and water loss can't match
            self.water_loss_mass = (((self.evaporative_heat_loss)/2.41)*3600)/1000.
            self.dehydration_mass -= self.water_loss_mass
            self.excess_water = 0.0
            self.excess_proportion_of_mass_lost = 0.0
            self.metabolic_heat_required = 0.0
            self.water_loss_required = (((self.energy_balance*-1.0)/2.41)*3600)/1000.
            self.proportion_water_loss_required = (self.water_loss_required)/self.MASS
            self.excess_metabolic_heat = 0.0
            self.water_stress = Qgen + self.evaporative_heat_loss
            self.heat_stress = 0.0
        elif self.energy_balance < 0.0 and Qgen > 0.0: #if you're gaining heat but it's cold outside (maybe due to metabolic rates being high)
            self.water_loss_mass = (((self.evaporative_heat_loss)/2.41)*3600)/1000.
            self.dehydration_mass -= self.water_loss_mass
            self.excess_water = 0.0
            self.excess_proportion_of_mass_lost = 0.0
            self.metabolic_heat_required = 0.0
            self.water_loss_required = (((self.energy_balance*-1.0)/2.41)*3600)/1000.
            self.proportion_water_loss_required = (self.water_loss_required)/self.MASS
            self.excess_metabolic_heat = self.energy_balance*-1.0
            self.water_stress = 0.0
            self.heat_stress = Qgen - self.resting_metabolic_rate
        else:
            print('Error: update energy balance function -> Qgen equals energy balance')
            
    def calculate_empirical_body_conductance(self,Te):
        'a function that calculates empirical body conductance, if physiology is known'
        return (self.resting_metabolic_rate - self.evaporative_heat_loss)/(self.T_b - Te)
        
    def biophysical_demand(self,Qgen):
        'a function that calculations hourly wattage'
        if Qgen < 0:
            self.Qgen_water = Qgen * 3600.
            self.Qgen_water_sum += Qgen
            self.Qgen_heat = 0.0
        elif Qgen > 0:
            self.Qgen_heat = Qgen
            self.Qgen_water = 0.0
        else:
            print('Error: biophysical demand function -> Qgen equals zero')
            
    def define_Tes_past(self,mins,maxes,day,hour,tau,soil_mins,soil_maxes,windspeed):
        'a functiont that calculates the operative temperature in the previous hour'
        if self.physiology_known == 1.0:
            if hour == 0.0:
                self.Tes_past = self.standard_operative_temperature(mins,maxes,day-1.,23.,tau,soil_mins,soil_maxes,windspeed)
                self.Qgen_past = self.Q_gen(mins,maxes,day-1.,23.,tau,soil_mins,soil_maxes,windspeed)
            else:
                pass
        else:
            if hour == 0.0:
                self.Tes_past = self.standard_operative_temperature(mins,maxes,day-1.,23.,tau,soil_mins,soil_maxes,windspeed)
                self.Qgen_past = self.Q_gen(mins,maxes,day-1.,23.,tau,soil_mins,soil_maxes,windspeed)
            else:
                pass
            
    def activity_thermal_stress(self,Tes_current,Tes_previous,species):
        'this function calculates activity, but was not used in the publication'
        self.activity_above_thermal_stress = 0.0
        if Tes_previous > self.Tb_max and Tes_current > self.Tb_max:
            self.activity_above_thermal_stress = 1.0
        elif Tes_previous < self.Tb_max and Tes_current > self.Tb_max:
            slope = Tes_current - Tes_previous
            intercept = Tes_current - (slope * hour)
            threshold_time = (self.Tb_max - intercept)/slope
            self.activity_above_thermal_stress = hour - threshold_time
        elif Tes_previous > self.Tb_max and Tes_current < self.Tb_max:
            slope = Tes_current - Tes_previous
            intercept = Tes_current - (slope * hour)
            threshold_time = (self.Tb_max - intercept)/slope
            self.activity_above_thermal_stress = hour - threshold_time
        elif Tes_previous < self.Tb_max and Tes_current < self.Tb_max:
            pass
        else:
            print("Error: condition not met in activity thermal stress function")
        
    def activity_water_stress(self,Tes_current,Tes_previous,Qgen_past):
        'this function calculates activity, but was not used in the publication'
        self.activity_above_water_stress = 0.0
        if Tes_previous <= 30.0:
            previous_water_heat_ratio = self.water_heat_ratio_intercept*exp((self.water_heat_ratio_slope*30.0))
            previous_evaporative_heat_loss = (self.water_loss_intercept*exp((self.water_loss_slope*30.)))/1000.
        elif Tes_previous > 30.0:
            previous_water_heat_ratio = self.water_heat_ratio_intercept*exp((self.water_heat_ratio_slope*Tes_previous))
            previous_evaporative_heat_loss = (self.water_loss_intercept*exp((self.water_loss_slope*Tes_previous)))/1000.
        previous_resting_metabolic_rate = previous_evaporative_heat_loss/previous_water_heat_ratio
        previous_water_heat_balance = previous_evaporative_heat_loss - previous_resting_metabolic_rate
        previous_energy_balance = Qgen_past + previous_water_heat_balance
        if previous_energy_balance > 0.0 and self.energy_balance < 0.0 or previous_energy_balance < 0.0 and self.energy_balance > 0.0:
            slope = self.energy_balance - previous_energy_balance
            intercept = self.energy_balance - (slope * hour)
            threshold_time = (0.0 - intercept)/slope
            self.activity_above_water_stress = hour - threshold_time
        elif previous_energy_balance < 0.0 and self.energy_balance < 0.0:
            self.activity_above_water_stress = 1.0
        else:
            pass
            
    def seek_shade(self,air_temperature,airT_threshold,mins,maxes,day,hour):
        'this function determines when organisms seek shade based upon the airT_threshold'
        if hour == 0.0:
            airT_previous = self.air_temp(mins,maxes,day-1,23)
        else:
            airT_previous = self.air_temp(mins,maxes,day,hour-1)
        if air_temperature > airT_threshold:
            if self.S == 0.5:
                self.active_hours = 1.0
            else:
                slope = air_temperature - airT_previous
                intercept = air_temperature - (slope * hour)
                x = (airT_threshold - intercept)/slope
                self.active_hours = (hour) - x
                if self.active_hours > 1.0:
                    sys.exit("Error in activity")
                self.S = 0.5
        else:
            if self.S == 1.0:
                self.active_hours = 0.0
                pass
            else:
                slope = air_temperature - airT_previous
                intercept = air_temperature - (slope * hour)
                x = (airT_threshold - intercept)/slope
                self.active_hours = (hour) - x
                if self.active_hours > 1.0:
                    sys.exit("Error in activity")
                self.S = 1.0
            
    def seek_shade_physiology(self):
        'this function seeks shade based on physiology, but was not used for the publication'
        if self.Qgen_water_threshold < self.Qgen_water_sum:
            self.S = 1.0
        else:
            self.S = 0.5
         
#----------------------------#
#----------FUNCTIONS---------#
#----------------------------#

def return_mins_maxes(climate_scenario):
    'this function returns the air temperatures for the climate scenarios'
    minTemps = array([-0.546295166,-0.546295166,0.997741699,2.381408691,5.67364502,10.63543701,16.46054077,20.15667725,18.3208313,14.36260986,9.014862061,3.021453857,-0.433563232,-0.433563232])#NicheMapR
    maxTemps= array([11.0,11.0,13.39996338,15.60003662,20.0,25.5,32.0,35.40002441,33.8999939,29.60003662,23.39996338,15.79998779,11.29998779,11.29998779])#NicheMapR, Mojave Desert air temperatures at
    soil_minTemps = array([-6.032876492,-6.032876492,-5.255892277,-3.224258423,-0.002847135,9.089467049,16.31286621,20.24597168,16.72836494,8.807407379,1.931162357,-4.292984486,-6.121925831,-6.121925831])#NicheMapR
    soil_maxTemps = array([18.65456963,18.65456963,23.08130455,27.32052231,34.15578079,41.35151672,49.53957748,52.88491821,52.39891815,46.26831818,36.57083511,24.43585205,18.50059891,18.50059891])#NicheMapR, Mojave Desert air temperatures at 
    max_proportion = soil_maxTemps/maxTemps
    min_proportion = (soil_minTemps+10)/(minTemps+10)
    if climate_scenario == 'microclim':
        minTemps = array([-0.546295166,-0.546295166,0.997741699,2.381408691,5.67364502,10.63543701,16.46054077,20.15667725,18.3208313,14.36260986,9.014862061,3.021453857,-0.433563232,-0.433563232])#NicheMapR
        maxTemps= array([11.0,11.0,13.39996338,15.60003662,20.0,25.5,32.0,35.40002441,33.8999939,29.60003662,23.39996338,15.79998779,11.29998779,11.29998779])#NicheMapR, Mojave Desert air temperatures at
        soil_minTemps = array([-6.032876492,-6.032876492,-5.255892277,-3.224258423,-0.002847135,9.089467049,16.31286621,20.24597168,16.72836494,8.807407379,1.931162357,-4.292984486,-6.121925831,-6.121925831])#NicheMapR
        soil_maxTemps = array([18.65456963,18.65456963,23.08130455,27.32052231,34.15578079,41.35151672,49.53957748,52.88491821,52.39891815,46.26831818,36.57083511,24.43585205,18.50059891,18.50059891])#NicheMapR, Mojave Desert air temperatures at 
    if climate_scenario == 'CURR':
        minTemps = array([5.5,5.8,6.3,7.5,10.7,16.1,21.8,26.5,25.5,21.7,15.7,10.1,6.1,5.8])
        maxTemps = array([15.0,15.3,16.9,19.3,23.6,29.4,35.3,39.3,38,34.1,28,21,15.9,15.5])
        soil_minTemps = array([-6.032876492,-6.032876492,-5.255892277,-3.224258423,-0.002847135,9.089467049,16.31286621,20.24597168,16.72836494,8.807407379,1.931162357,-4.292984486,-6.121925831,-6.121925831])#NicheMapR
        soil_maxTemps = array([18.65456963,18.65456963,23.08130455,27.32052231,34.15578079,0,0,0,0,0,36.57083511,24.43585205,18.50059891,18.50059891])
    elif climate_scenario == 'CC45':
        minTemps = array([4.3,4.6,5.4,6.4,9.6,14.6,20.6,24.8,23.6,20,14.1,8.0,4.5,4.2])
        maxTemps = array([14.3,14.6,15.6,18.3,22.4,27.8,34.4,37.8,36.3,32.6,26.6,19.1,14.4,14.0])
        soil_minTemps = (minTemps+10 * min_proportion) - 10
        soil_maxTemps = maxTemps * max_proportion
    elif climate_scenario == 'CC60':
        minTemps = array([4.3,4.4,5.5,6.6,10.0,15.0,20.7,25.0,23.9,20.0,14.4,8.4,5.0,4.8])
        maxTemps = array([13.4,14.0,16.0,18.4,23.3,28.4,34.4,38.1,36.5,32.8,26.9,19.4,15.0,14.7])
        soil_minTemps = (minTemps+10 * min_proportion) - 10
        soil_maxTemps = maxTemps * max_proportion
    elif climate_scenario == 'CC85':
        minTemps = array([5.5,5.8,6.3,7.5,10.7,16.1,21.8,26.5,25.5,21.7,15.7,10.1,6.1,5.8])
        maxTemps = array([15.0,15.3,16.9,19.3,23.6,29.4,35.3,39.3,38,34.1,28,21,15.9,15.5])
        soil_minTemps = (minTemps+10 * min_proportion) - 10
        soil_maxTemps = maxTemps * max_proportion
    elif climate_scenario == 'historic':
        minTemps = array([-1.1,-1.2284999999999999, -0.34899999999999998, 1.4519999999999995, 4.319, 8.0895000000000028, 13.536999999999997, 17.003999999999998, 16.490500000000001, 12.770000000000001, 7.3360000000000003, 2.5114999999999998, -1.6335000000000002,-1.5])
        maxTemps = array([8.9,9.0584999999999987, 10.206500000000002, 13.477499999999997, 17.541, 21.778000000000002, 28.048999999999999, 30.792000000000002, 29.916499999999996, 26.399999999999995, 20.1555, 14.280000000000001, 9.1319999999999979,9.12])
        soil_minTemps = (minTemps+10 * min_proportion) - 10
        soil_maxTemps = maxTemps * max_proportion
    elif climate_scenario == 'modern':
        minTemps = array([-0.24,-0.25000000000000011, 0.71049999999999991, 2.8299999999999996, 4.9719999999999995, 10.089, 14.3475, 18.6035, 17.861000000000001, 14.542499999999999, 8.5870000000000015, 3.3195000000000001, -0.19,-0.18])
        maxTemps = array([9.8,9.9435000000000002, 10.885000000000002, 14.635999999999999, 17.3565, 23.222999999999999, 28.139500000000005, 31.493500000000001, 30.669999999999998, 27.363999999999997, 20.714000000000002, 14.056000000000001, 9.5389999999999979,9.4])
        soil_minTemps = (minTemps+10 * min_proportion) - 10
        soil_maxTemps = maxTemps * max_proportion
    elif climate_scenario == 'site1':
        minTemps = array([-7.4,-7.5,-7.5,-7.5,-5.4,-2.2,2,5.9,5.5,2.7,-0.8,-4.5,-6.8,-7.4])
        maxTemps = array([4.7,4.6,3.9,3.9,7,11.6,17.4,20.4,19.6,16.9,12.6,7.3,4.9,4.7])
        soil_minTemps = (minTemps+10 * min_proportion) - 10
        soil_maxTemps = maxTemps * max_proportion
    elif climate_scenario == 'site2':
        minTemps = array([-7.3,-7.6,-7,-6.2,-3.4,0.6,5.2,9,8.3,5,0.7,-4.1,-7.2,-7.3])
        maxTemps = array([4.3,4.2,4.6,5.8,9.5,14.6,20.5,24.1,22.8,19.2,14.1,7.8,4.4,4.3])
        soil_minTemps = (minTemps+10 * min_proportion) - 10
        soil_maxTemps = maxTemps * max_proportion
    elif climate_scenario == 'site3':
        minTemps = array([-0.3,-0.5,0.5,1.5,4.1,7.7,12.4,16.2,15.6,12.1,7.2,2.5,-0.4,-0.3])
        maxTemps = array([12.85,12.7,14.3,15.8,19.9,24.7,30.4,33.5,32.5,29.2,23.7,16.9,13,12.85])
        soil_minTemps = (minTemps+10 * min_proportion) - 10
        soil_maxTemps = maxTemps * max_proportion
    elif climate_scenario == 'site4':
        minTemps = array([3.7,3.6,4.6,5.4,7.2,9.9,12.7,16,16.2,14.2,10.4,6.5,3.8,3.7])
        maxTemps = array([17.7,17.3,18.8,19.7,22.5,25.4,29.6,34.5,34.2,31.8,27.1,21.5,18.1,17.7])
        soil_minTemps = (minTemps+10 * min_proportion) - 10
        soil_maxTemps = maxTemps * max_proportion
    elif climate_scenario == 'site5':
        minTemps = array([2.1,2.2,4.6,6.9,10.3,14.9,19.2,23.1,22.3,18.4,12.5,6,2,2.1])
        maxTemps = array([16.5,16.4,19.3,22.1,26.5,31.5,37,40.5,39.3,35.4,29.1,21.4,16.6,16.5])
        soil_minTemps = (minTemps+10 * min_proportion) - 10
        soil_maxTemps = maxTemps * max_proportion
    elif climate_scenario == 'site6':
        minTemps = array([4.55,4.5,6.6,9.2,12.6,16.4,20.6,25.3,25.3,21.6,15.1,8.5,4.6,4.55])
        maxTemps = array([20.1,20.2,23.1,26.3,30.4,34.8,39.7,41.9,41.3,39,33.2,25.6,20.6,20.5])
        soil_minTemps = (minTemps+10 * min_proportion) - 10
        soil_maxTemps = maxTemps * max_proportion
    days = array([-16, 15, 46, 75, 106, 136, 167, 197, 228, 259, 289, 320, 350, 381])
    maxT = UnivariateSpline(days, maxTemps, k=3)
    minT = UnivariateSpline(days, minTemps, k=3)
    maxes = maxT(arange(365))  
    mins = minT(arange(365))
    soil_maxT = UnivariateSpline(days, soil_maxTemps, k=3)
    soil_minT = UnivariateSpline(days, soil_minTemps, k=3)
    soil_maxes = soil_maxT(arange(365))  
    soil_mins = soil_minT(arange(365))
    return mins,maxes,soil_mins,soil_maxes

def generate_mass(mass):
    'this function generates the list of masses to use for understanding the effect of reducing body size'
    mass_change =  array((uniform(0,10)/100,uniform(0,10)/100,uniform(0,10)/100,uniform(0,10)/100,uniform(0,10)/100,uniform(10,20)/100,uniform(10,20)/100,uniform(10,20)/100,uniform(10,20)/100,uniform(10,20)/100,uniform(20,30)/100,uniform(20,30)/100,uniform(20,30)/100,uniform(20,30)/100,uniform(20,30)/100))
    masses = repeat(mass,15)
    mass_list = masses-(masses*mass_change)
    change = mass_change
    mass_list = numpy.insert(mass_list,0,mass)
    change = numpy.insert(change,0,0)
    return mass_list,change

def generate_seek():
    'this function generates a list of temperatures to seek to understand shade seeking behavior'
    seek_temperatures =  array((uniform(35,40),uniform(35,40),uniform(35,40),uniform(35,40),uniform(35,40),uniform(30,35),uniform(30,35),uniform(30,35),uniform(30,35),uniform(30,35),uniform(25,30),uniform(25,30),uniform(25,30),uniform(25,30),uniform(25,30)))
    seek_temperatures = numpy.insert(seek_temperatures,0,35.0)
    return list(seek_temperatures)
    
#--------------#
#  DATAFRAMES  #
#--------------#
'the file contains all of the species parameters'
species = pandas.read_csv('your_path/endotherm_properties_v3.csv')

#---------------#
#  SENSITIVITY  #
#---------------#
'the follow variables can be adjusted to understand the sensitivity of our model'
windspeeds = [0.1]# [0.1,1.0,2.0,3.0]
posture = [0.0]#for azimuth function, [-0.5,-0.25,0.0,0.25,0.5]
fiber_density = [0.0]#for self.fiber_number, [-0.5,-0.25,0.0,0.25,0.5]
shade_list = [0.0] #for self.S,[0.0,-0.25,-0.5]
feather_depth = [0.0]#for insulation_depth, [-0.5,-0.25,0.0,0.25,0.5]
orientation = [0.0]#for view_factor,[0.0,-0.25,-0.5,-0.75]
shape = [0.0]#for length, [-0.5,-0.25,0.0,0.25,0.5]
climates = ['modern','historic']#,'CC45','CC60','CC85']#['CURR','CC45','CC60','CC85'], ['modern','historic'],['site1','site2','site3','site4','site5','site6']


#-----------------#
#    SIMULATION   #
#-----------------#
'the simulation that runs through all the calculations'
hourly_results = pandas.DataFrame(columns = ['species','version','climate_scenario','mass_change','seek_temperature','wind','posture','fiber_density','shade','feather_depths','orientation','shape','physiology_known', 'significant', 'elevational_preference','habitat','diet','migratory','mass','surface_area','occupancy_decline','julian_day','hour','Tes','Tair','Te_dorsal','Hi_d','Ri_d','Ks','Kf_d','Ksfi_d','Ke_d','Ke_empirical','Ke_theoretical','Tb','Qgen','EHL','MHP','EHL/MHP','energy_balance','water_loss_mass','dehydration_mass','excess_proportion_of_mass_lost','excess_water','metabolic_heat_required','water_loss_required','proportion_water_loss_required','excess_metabolic_heat','Qgen_water_avg','Qgen_water_sum','Qgen_heat','activity_thermal_stress','activity_water_stress','water_stress','heat_stress','hr_restriction'])
for spp in range(len(species)):
    start_time = time.time()
    mass_list = [[species.vertnet_mass[spp]],[0]]
    for climate_scenario in range(len(climates)):
        Temps = return_mins_maxes(climates[climate_scenario])
        mins = Temps[0]
        maxes = Temps[1]
        soil_mins = Temps[2]
        soil_maxes = Temps[3]
        for each_mass in range(len(mass_list[0])):
            seek_temperatures = [35.0]
            julian_day = [197.0]
            for each_seek in range(len(seek_temperatures)):
                for winds in range(len(windspeeds)):
                    for postures in range(len(posture)):
                        for densities in range(len(fiber_density)):
                            for shades in range(len(shade_list)):
                                for depths in range(len(feather_depth)):
                                    for orientations in range(len(orientation)):
                                        for shapes in range(len(shape)):
                                            endotherm = Individual(species.type[spp],climates[climate_scenario],species.common_name[spp],35.0110,-115.4734,species.length[spp],species.width[spp],species.height[spp],species.feather_length_dorsal[spp],species.feather_length_ventral[spp],species.density_of_fibers[spp],species.insulation_depth_dorsal[spp],species.insulation_depth_ventral[spp],species.physiology_known[spp],species.body_temperature_min[spp],species.body_temperature_max[spp],species.lower_critical_temperature[spp],species.upper_critical_temperature[spp],mass_list[0][each_mass],species.shortwave_absorptance_dorsal[spp],species.shortwave_absorptance_ventral[spp],species.longwave_absorptance[spp],species.water_heat_ratio_slope[spp],species.water_heat_ratio_intercept[spp],species.water_loss_slope[spp],species.water_loss_intercept[spp],species.body_temperature_slope1[spp],species.body_temperature_slope2[spp],species.body_temperature_intercept[spp],0.1,posture[postures],fiber_density[densities],shade_list[shades],feather_depth[depths],orientation[orientations],mass_list[1][each_mass],species.water_threshold[spp])
                                            for j in range(len(julian_day)):
                                                for hour in arange(0,24,(1)):
                                                    if species.physiology_known_master[spp] == 1.0:
                                                        endotherm.define_Tes_past(mins,maxes,julian_day[j],hour,TAU,soil_mins,soil_maxes,windspeeds[winds])
                                                        Tes = endotherm.standard_operative_temperature(mins,maxes,julian_day[j],hour,TAU,soil_mins,soil_maxes,windspeeds[winds])
                                                        endotherm.update_Tb(Tes,species.body_temperature_max[spp])
                                                        Tes = endotherm.standard_operative_temperature(mins,maxes,julian_day[j],hour,TAU,soil_mins,soil_maxes,windspeeds[winds])
                                                        endotherm.update_skin_conductance(Tes)
                                                        Tes = endotherm.standard_operative_temperature(mins,maxes,julian_day[j],hour,TAU,soil_mins,soil_maxes,windspeeds[winds])
                                                        Te = endotherm.operative_temperature(mins,maxes,julian_day[j],hour,TAU,soil_mins,soil_maxes,windspeeds[winds])
                                                        Qgen = endotherm.Q_gen(mins,maxes,julian_day[j],hour,TAU,soil_mins,soil_maxes,windspeeds[winds])
                                                        endotherm.update_water_loss_rate(Tes)
                                                        endotherm.update_water_heat_ratio(Tes)
                                                        endotherm.update_water_heat_balance()
                                                        endotherm.update_energy_balance(Qgen)
                                                        Ke_empirical = endotherm.calculate_empirical_body_conductance(Te)
                                                        Ke_theoretical = endotherm.Ke_overall(mins,maxes,julian_day[j],hour,soil_mins,soil_maxes,windspeeds[winds])
                                                        endotherm.biophysical_demand(Qgen)
                                                        endotherm.activity_thermal_stress(Tes,endotherm.Tes_past,species.species[spp])
                                                        endotherm.activity_water_stress(Tes,endotherm.Tes_past,endotherm.Qgen_past)
                                                        endotherm.Tes_past = Tes
                                                        endotherm.Qgen_past = Qgen
                                                        Hi_d = endotherm.convective_conductance(mins,maxes,julian_day[j],hour,soil_mins,soil_maxes,windspeeds[winds])/(endotherm.surface_area_outer/2.0)
                                                        Ri_d = endotherm.radiative_conductance(mins,maxes,julian_day[j],hour,soil_mins,soil_maxes)/(endotherm.surface_area_outer/2.0)
                                                        Ks = endotherm.conductance_skin#W m-2 C-1
                                                        Kf_d = endotherm.conductance_insulation_dorsal#W m-2 K-1
                                                        Ksfi_d = (endotherm.conductance_skin * endotherm.conductance_insulation_dorsal)/(endotherm.conductance_skin + endotherm.conductance_insulation_dorsal)
                                                        Ke_d = endotherm.effective_conductance("dorsal",endotherm.radiative_conductance(mins,maxes,julian_day[j],hour,soil_mins,soil_maxes),endotherm.convective_conductance(mins,maxes,julian_day[j],hour,soil_mins,soil_maxes,windspeeds[winds]))/endotherm.surface_area_outer#W m-2 K-1
                                                        dorsal_Te = endotherm.air_temp(mins,maxes,julian_day[j],hour) + (((endotherm.radiation_abs('dorsal',mins,maxes,julian_day[j],hour,TAU,soil_mins,soil_maxes,windspeeds[winds])*(endotherm.surface_area_outer/2.))-(endotherm.E_S*STEFAN_BOLTZMANN*((273.5 + endotherm.air_temp(mins,maxes,julian_day[j],hour))**4)*(endotherm.surface_area_outer/2.)))/((endotherm.convective_conductance(mins,maxes,julian_day[j],hour,soil_mins,soil_maxes,windspeeds[winds]))+endotherm.radiative_conductance(mins,maxes,julian_day[j],hour,soil_mins,soil_maxes))) #Bakken, bird
                                                        Tair = endotherm.air_temp(mins,maxes,julian_day[j],hour)
                                                    else:
                                                        endotherm.seek_shade(endotherm.air_temp(mins,maxes,julian_day[j],hour),seek_temperatures[each_seek],mins,maxes,julian_day[j],hour)
                                                        endotherm.define_Tes_past(mins,maxes,julian_day[j],hour,TAU,soil_mins,soil_maxes,windspeeds[winds])
                                                        Tes = endotherm.standard_operative_temperature(mins,maxes,julian_day[j],hour,TAU,soil_mins,soil_maxes,windspeeds[winds])
                                                        endotherm.update_skin_conductance(Tes)
                                                        Tes = endotherm.standard_operative_temperature(mins,maxes,julian_day[j],hour,TAU,soil_mins,soil_maxes,windspeeds[winds])
                                                        Te = endotherm.operative_temperature(mins,maxes,julian_day[j],hour,TAU,soil_mins,soil_maxes,windspeeds[winds])
                                                        Qgen = endotherm.Q_gen(mins,maxes,julian_day[j],hour,TAU,soil_mins,soil_maxes,windspeeds[winds])
                                                        Ke_empirical = endotherm.calculate_empirical_body_conductance(Te)
                                                        Ke_theoretical = endotherm.Ke_overall(mins,maxes,julian_day[j],hour,soil_mins,soil_maxes,windspeeds[winds])/abs(endotherm.T_b - Te)
                                                        endotherm.biophysical_demand(Qgen)
                                                        endotherm.activity_thermal_stress(Tes,endotherm.Tes_past,species.species[spp])
                                                        endotherm.Tes_past = Tes
                                                        endotherm.Qgen_past = Qgen
                                                        Hi_d = endotherm.convective_conductance(mins,maxes,julian_day[j],hour,soil_mins,soil_maxes,windspeeds[winds])
                                                        Ri_d = endotherm.radiative_conductance(mins,maxes,julian_day[j],hour,soil_mins,soil_maxes)
                                                        Ks = endotherm.conductance_skin
                                                        Kf_d = endotherm.conductance_insulation_dorsal
                                                        Ksfi_d = (endotherm.conductance_skin * endotherm.conductance_insulation_dorsal)/(endotherm.conductance_skin + endotherm.conductance_insulation_dorsal)
                                                        Ke_d = endotherm.effective_conductance("dorsal",endotherm.radiative_conductance(mins,maxes,julian_day[j],hour,soil_mins,soil_maxes),endotherm.convective_conductance(mins,maxes,julian_day[j],hour,soil_mins,soil_maxes,windspeeds[winds]))
                                                        dorsal_Te = endotherm.air_temp(mins,maxes,julian_day[j],hour) + (((endotherm.radiation_abs('dorsal',mins,maxes,julian_day[j],hour,TAU,soil_mins,soil_maxes,windspeeds[winds])*(endotherm.surface_area_outer/2.))-(endotherm.E_S*STEFAN_BOLTZMANN*((273.5 + endotherm.air_temp(mins,maxes,julian_day[j],hour))**4)*(endotherm.surface_area_outer/2.)))/((endotherm.convective_conductance(mins,maxes,julian_day[j],hour,soil_mins,soil_maxes,windspeeds[winds]))+endotherm.radiative_conductance(mins,maxes,julian_day[j],hour,soil_mins,soil_maxes))) #Bakken, bird
                                                        Tair = endotherm.air_temp(mins,maxes,julian_day[j],hour)
                                                    dataframe = pandas.DataFrame([[species.common_name[spp],species.version[spp],climates[climate_scenario],mass_list[0][each_mass],seek_temperatures[each_seek],windspeeds[winds],posture[postures],fiber_density[densities],shade_list[shades],feather_depth[depths],orientation[orientations],shape[shapes],species.physiology_known[spp],species.significant[spp],species.elevational_preference[spp],species.habitat[spp],species.diet[spp],species.migratory[spp],species.vertnet_mass[spp],endotherm.surface_area_outer,species.occupancy_decline[spp],julian_day[j],hour,Tes,Tair,dorsal_Te,Hi_d,Ri_d,Ks,Kf_d,Ksfi_d,Ke_d,Ke_empirical,Ke_theoretical,endotherm.T_b,Qgen,endotherm.evaporative_heat_loss,endotherm.resting_metabolic_rate,endotherm.water_heat_balance,endotherm.energy_balance,endotherm.water_loss_mass,endotherm.dehydration_mass,endotherm.excess_proportion_of_mass_lost,endotherm.excess_water,endotherm.metabolic_heat_required,endotherm.water_loss_required,endotherm.proportion_water_loss_required,endotherm.excess_metabolic_heat,endotherm.Qgen_water,endotherm.Qgen_water,endotherm.Qgen_heat,endotherm.activity_above_thermal_stress,endotherm.activity_above_water_stress,endotherm.water_stress,endotherm.heat_stress,endotherm.active_hours]],columns = ['species','version','climate_scenario','mass_change','seek_temperature','wind','posture','fiber_density','shade','feather_depths','orientation','shape','physiology_known', 'significant', 'elevational_preference','habitat','diet','migratory','mass','surface_area','occupancy_decline','julian_day','hour','Tes','Tair','Te_dorsal','Hi_d','Ri_d','Ks','Kf_d','Ksfi_d','Ke_d','Ke_empirical','Ke_theoretical','Tb','Qgen','EHL','MHP','EHL/MHP','energy_balance','water_loss_mass','dehydration_mass','excess_proportion_of_mass_lost','excess_water','metabolic_heat_required','water_loss_required','proportion_water_loss_required','excess_metabolic_heat','Qgen_water_avg','Qgen_water_sum','Qgen_heat','activity_thermal_stress','activity_water_stress','water_stress','heat_stress','hr_restriction'])
                                                    hourly_results = hourly_results.append(dataframe)
end_time = time.time()
hourly_results.to_csv('your_path/hourly_v14_standard.csv',columns=['species','version','climate_scenario','mass_change','seek_temperature','wind','posture','fiber_density','shade','feather_depths','orientation','shape','physiology_known', 'significant', 'elevational_preference','habitat','diet','migratory','mass','surface_area','occupancy_decline','julian_day','hour','Tes','Tair','Te_dorsal','Hi_d','Ri_d','Ks','Kf_d','Ksfi_d','Ke_d','Ke_empirical','Ke_theoretical','Tb','Qgen','EHL','MHP','EHL/MHP','energy_balance','water_loss_mass','dehydration_mass','excess_proportion_of_mass_lost','excess_water','metabolic_heat_required','water_loss_required','proportion_water_loss_required','excess_metabolic_heat','Qgen_water_avg','Qgen_water_sum','Qgen_heat','activity_thermal_stress','activity_water_stress','water_stress','heat_stress','hr_restriction'],index = False)             

#-----------------#
#    SUMMARIZE    #
#-----------------#
'summarize the hourly data'

hourly = pandas.read_csv('your_path/hourly_v14_standard.csv')
daily_results = hourly.groupby(['species','version','climate_scenario','mass_change','seek_temperature','wind','posture','fiber_density','shade','feather_depths','orientation','shape'],as_index=False)
daily_df = daily_results.agg(OrderedDict([
                 ('physiology_known' , mean),
                 ('significant' , mean),
                 ('elevational_preference' , mean),
                 ('habitat' , mean),
                 ('diet' , mean),
                 ('migratory' , mean),
                 ('mass' , mean),
                 ('occupancy_decline',mean),
                 ('Tes' , mean),
                 ('Qgen' , mean),
                 ('EHL' , mean),
                 ('MHP' , mean),
                 ('EHL/MHP' , mean),
                 ('energy_balance' , mean),
                 ('water_loss_mass' , mean),
                 ('dehydration_mass' , mean),
                 ('excess_proportion_of_mass_lost' , mean),
                 ('excess_water' , sum),
                 ('metabolic_heat_required' , sum),
                 ('water_loss_required' , sum),
                 ('excess_metabolic_heat',sum),
                 ('proportion_water_loss_required' , sum),
                 ('Qgen_water_avg' , mean),
                 ('Qgen_water_sum' , sum),
                 ('Qgen_heat' , mean),
                 ('activity_thermal_stress' , sum),
                 ('activity_water_stress' , sum),
                 ('water_stress',mean),
                 ('heat_stress',mean),
                 ('hr_restriction',sum)
                ]))
daily_df.to_csv('your_path/bird_simulations_daily_v14_standard.csv',index = False)
daily_df_calc = pandas.read_csv('Documents/manuscripts/grinnell_resurvey_project/results/simulation_data/v14_standard/bird_simulations_daily_v14_standard.csv')
daily_df_calc['logQwater_avg'] = (log(daily_df_calc.Qgen_water_avg*-1.))
daily_df_calc['logQwater_sum'] = (log(daily_df_calc.Qgen_water_sum*-1.))
daily_df_calc['logQheat'] = log(daily_df_calc.Qgen_heat)
daily_df_calc['dehydration_status'] = ((daily_df_calc.mass - daily_df_calc.dehydration_mass)/daily_df_calc.mass)*100.
daily_df_calc.to_csv('your_path/bird_simulations_daily_v14_standard.csv',columns=['species','version','climate_scenario','mass_change','seek_temperature','wind','posture','fiber_density','shade','feather_depths','orientation','shape','physiology_known', 'significant', 'elevational_preference','habitat','diet','migratory','mass','occupancy_decline','Tes','Qgen','EHL','MHP','EHL/MHP','energy_balance','water_loss_mass','dehydration_mass','excess_proportion_of_mass_lost','excess_water','metabolic_heat_required','water_loss_required','excess_metabolic_heat','proportion_water_loss_required','Qgen_water_avg','Qgen_water_sum','Qgen_heat','logQwater_avg','logQwater_sum','logQheat','dehydration_status','activity_thermal_stress','activity_water_stress','water_stress','heat_stress','hr_restriction'],index = False)

#-----------------#
#  CALCULATIONS   #
#-----------------#
'compare modern and historic climates'
df = pandas.read_csv('your_path/bird_simulations_daily_v14_standard.csv')

df_m = df.drop(df[df.climate_scenario == 'historic'].index)
df_h = df.drop(df[df.climate_scenario == 'modern'].index)

df_m = df_m.reset_index(drop=True)
df_h = df_h.reset_index(drop=True)

results = pandas.DataFrame({"species":df_m.species})
results['Q_water_modern'] = df_m.Qgen_water_sum
results['Q_water_historic'] = df_h.Qgen_water_sum
results['Q_water_difference'] = df_h.Qgen_water_sum - df_m.Qgen_water_sum
results['Q_water_proportion'] = results['Q_water_difference']/abs(results['Q_water_historic'])
results['log_Q_water_diff'] = log(df_h.Qgen_water_sum - df_m.Qgen_water_sum)
results['log_mass'] = log(df_h.mass)
results['occupancy'] = df_h.occupancy_decline

results.to_csv('your_path/bird_simulations_daily_v14_standard_analysis.csv')

print('Your simulation is complete')
